# How this works

The Readme is adjacent to this file for how to use the package. This file is for
how the package works.

# Design Tokens

Design Tokens are values that can be shared between development and design, and
then down the chains in each respective discipline.

We need a way to represent those values that is framework and platform agnostic.

By doing so, we can easily transform those values into framework, and platform
specific values.

# What is in this Repo? Where do I start?

Short answer, `src/tokens` contains all of our design tokens. They are in the
W3C standard format https://tr.designtokens.org/format/

To consume those tokens, we've written a custom parser so that we can ensure
compatiblity with our legacy systems (more on the parser later).

We deviate mildly from the w3c standard in two ways:

1. We use HSL instead of HEX for our colour values. This was a conscious
   decision for readability. We do not modify the HSL values in transit as they
   are understood in both the web, and react-native.
1. We are taking advantage of the liberal naming policy of tokens to support our
   double dash (--) naming pattern. You will see this in token naming with a `-`
   at the end of a token name. The `-` indicates this will resolve to a
   double-dash.

The tokens are generated from the `scripts/buildTokens.ts` file.

There is a `tokenServices` folder which is broken down into three main files:

1. `tokenParsing` is the service that parses/loads the tokens directly from the
   JSON token files. It also provides functions to convert token aliases
   directly to values.
1. `tokenFileGeneration` is the service that takes output from `tokenParsing`
   and generates content ready to be written to files.
1. `tokenConvienence` is the service that combines functions from both
   `tokenParsing` and `tokenFileGeneration` into easy-to-use, opinionated
   methods that are easy to read.

Beyond those main files, `allTokens` makes it easy to work with all of our
tokens. `tokenConstants` has any hard-coded constants. Currently that's just our
base-unit. `tokenTypes` is the types used in all 3 files.

# What artifacts are currently generated by this process?

The actual content of `buildTokens` are calls to `tokenConvienence` functions to
build the following files:

1. assets/tokens.android.ts - Android specific tokens
1. assets/tokens.color.ts - Our color tokens. These are required in Storybook to
   display color swatches. Possibly an opportunity to replace with semantic now
   that we have it.
1. In addition, tokens.color.ts is also copied to dist/colors.mjs and
   dist/colors.cjs for legacy compatability.
1. assets/tokens.dark.ts - Dark Tokens.
1. assets/tokens.ios.ts - IOS specific tokens
1. assets/tokens.semantic.ts - Our Semantic Tokens
1. assets/tokens.web.ts - Web specific tokens.

All of the above files are now also made available via `index` or by importing
from `import {tokensDark,...} from '@jobber/design'`

In addition to those files, the `buildTokens` script also creates:

1. dist/colors.css made up of the tokens from assets/tokens.color.ts
1. dist/semantic.css made up of the tokens from assets/tokens.semantic.ts
1. dist/dark.theme.css made up of the dark mode tokens from
   assets/tokens.dark.ts
1. dist/dark.mode.css made up of the dark mode tokens from assets/tokens.dark.ts
   and the elevated tokens, ready to be used in an application.

# How does all of this actually work?

1. Tokens are loaded from src/tokens, one by one.
1. Each token file is passed to `recurseTokenTree` which steps through
   structure, building a flat list of tokens.
1. Token Aliases https://tr.designtokens.org/format/#aliases-references can then
   be processed (if desired). They can be turned into actual values, or JS
   object references.
1. After token Aliases are processed, the tokens can be further processed into
   JS or CSS files, ready to be printed.

There are lots of comments on every function starting from `buildTokens`

# What about buildIconMap.ts, living next door to buildTokens?

In addition to being a token management tool, our design package also manages
our icons. We do that on two fronts:

1. We read the list of icons under src/icons, and we pull the `path` data for
   each icon (svg). We then store those paths indexed against the file/icon name
   in `assets/icon.map.ts`
1. This file is then read in `index.ts` in the `getIcon` function. The `getIcon`
   function is shared across react and react-native to get the meta data for an
   icon in a framework agnostic pattern. The `getIcon` function takes in an icon
   name, a color name, and a size. It then looks up the `path` data for that
   icon indexing on the name inside `assets/icon.map.ts`, and then looks up
   associated styles and colors in the `iconStyles` folder.

# Why did you go from className to style={} for Icon?

Based on what I could gather, we initially coded our solution for the web. We
then tried to get it working inside react-native, which involved a bit of a song
and dance to convert the styles to and from (since react-native doesn't
understand css).

This way forward drastically reduces the complexity for how Icon works in
react-native. It was a bit of a parity move for normal, web react but the
bonuses on the react-native side made the switch worth it.

Also it's just much, much easier to reason about now.

That said, we could walk this back if someone has a good reason to keep
className based styling for Icon (we wouldn't necessarily go back to the old
way, but maybe just adapt to use CSS on the web)
