# DataTable

# Data Table

Data Tables are used to organize and display tabular data to users while
providing a multitude of features that allows the user to interact with the data
been displayed on the table.

The standard DataTable component is a fast, consistent way to display structured
data with built-in layout, styling, and accessibility. It supports sorting,
pagination, and filtering either on the client or server.

For more advanced use cases, you can now use atomic DataTable components (e.g.,
`Row`, `Cell`, `HeaderCell`) in combination with other Atlantis components to
build fully custom table layouts. This enables greater flexibility in the types
of content you can render in rows and cells like icons, inline labels, action
buttons, or multi-line content.

If you're using a table library (such as
[TanStack Table](https://tanstack.com/table/latest)), you can combine its logic
with our atomic components to fully control the behavior and layout. This
enables sorting, filtering, pagination, and row or bulk actions. The atomic
components provide layout and styling only — they do not prescribe any data
logic or behavior.

## Design & usage guidelines

The DataTable component is a great solution if you are looking to display data
in a tabular way while giving your user the ability to sort, paginate or filter
that data, this can be implemented on the server side or on the client side
depending on your needs.

A best practice in DataTable presentation is to ensure that all columns with
numerical data (and their headers) round to the same decimal point, and are
right-aligned. This makes it much easier for the reader to quickly parse large
distinctions in dollar amounts, inventory counts, and other key business data.

If you have a small list of information with a 1:1 label-to-data relationship
(for example, the issued and due dates on an invoice), consider using
[DescriptionList](/components/DescriptionList).

**Note**: The atomic DataTable components are the path forward and should be
considered prior to using the [DataList](/components/DataList) and
[Table](/components/Table) components.

## Responsiveness

The standard DataTable component has the option to handle responsive design,
these options will allow us to fix the header or the first left column depending
on your needs, this will allow the user a more efficient way to visualize the
data.

When using atomic components, you can build your own responsive behavior. This
allows for greater flexibility, especially when working with table libraries
that control column visibility or mobile-friendly views. Atomic layouts let you
fully customize how data collapses or stacks at different breakpoints.

## Web Component Code

```tsx
DataTable Thicklist Table Web React import type { Row, Table } from "@tanstack/react-table";
import { flexRender } from "@tanstack/react-table";
import classNames from "classnames";
import type { ReactNode } from "react";
import React, { useCallback } from "react";
import styles from "./DataTable.module.css";
import { BodyLoading } from "./BodyLoading";

interface BodyProps<T> {
  readonly table: Table<T>;
  readonly onRowClick?: (row: Row<T>) => void;
  readonly emptyState?: ReactNode | ReactNode[];
  readonly loading: boolean;
}

export function Body<T extends object>({
  table,
  onRowClick,
  emptyState,
  loading,
}: BodyProps<T>) {
  const bodyRowClasses = classNames({ [styles.clickableRow]: !!onRowClick });

  const handleRowClick = useCallback(
    (row: Row<T>) => () => {
      if (onRowClick == undefined) return;
      onRowClick(row);
    },
    [onRowClick],
  );

  if (loading) {
    return <BodyLoading table={table} />;
  }

  return (
    <>
      {table.getRowModel().rows.length ? (
        <tbody>
          {table.getRowModel().rows.map(row => {
            return (
              <tr
                key={row.id}
                onClick={handleRowClick(row)}
                className={bodyRowClasses}
              >
                {row.getVisibleCells().map(cell => {
                  return (
                    <td
                      key={cell.id}
                      style={{
                        width: cell.column.getSize(),
                        minWidth: cell.column.columnDef.minSize,
                        maxWidth: cell.column.columnDef.maxSize,
                      }}
                    >
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext(),
                      )}
                    </td>
                  );
                })}
              </tr>
            );
          })}
        </tbody>
      ) : (
        <tbody>
          <tr className={bodyRowClasses}>
            <td
              colSpan={table.getAllColumns().length}
              className={styles.emptyStateCell}
            >
              <div className={styles.emptyState}>{emptyState}</div>
            </td>
          </tr>
        </tbody>
      )}
    </>
  );
}
import React from "react";
import type { Table } from "@tanstack/react-table";
import { Glimmer } from "../Glimmer";

interface BodyLoadingProps<T> {
  readonly table: Table<T>;
}

export function BodyLoading<T extends object>({ table }: BodyLoadingProps<T>) {
  const loaderRows = table.getState().pagination.pageSize;
  const loaderColumns = table.getAllColumns().length;

  return (
    <tbody>
      {Array.from(Array(loaderRows).keys()).map(row => (
        <tr key={row}>
          {Array.from(Array(loaderColumns).keys()).map(arr => (
            <td key={arr}>
              <Glimmer />
            </td>
          ))}
        </tr>
      ))}
    </tbody>
  );
}
import type { ColumnDef, Row } from "@tanstack/react-table";
import { useReactTable } from "@tanstack/react-table";
import classNames from "classnames";
import type { LegacyRef, ReactNode } from "react";
import React from "react";
import {
  Breakpoints,
  useResizeObserver,
} from "@jobber/hooks/useResizeObserver";
import { Body } from "./Body";
import { createTableSettings } from "./createTableSettings";
import styles from "./DataTable.module.css";
import { Pagination } from "./Pagination";
import type { PaginationType, SortingType } from "./types";
import { Footer } from "./Footer";
import { Header } from "./Header";
import {
  DataTableActions,
  DataTableBody,
  DataTableCell,
  DataTableContainer,
  DataTableFooter,
  DataTableHeader,
  DataTableHeaderCell,
  DataTablePagination,
  DataTablePaginationButton,
  DataTableRow,
  DataTableRowActions,
  DataTableSortableHeader,
  DataTableTable,
} from "./components";

export interface DataTableProps<T> {
  /**
   * The actual data that will be used for the table.
   * Typescript should infer T from typeof data.
   *
   */
  readonly data: T[];

  /**
   * Should follow the @tanstack/react-table [ColumnDef](https://tanstack.com/table/v8/docs/guide/column-defs).
   * [createColumnHelper](https://tanstack.com/table/v8/docs/guide/column-defs#column-helpers) is also exposed to make it more convenient
   * to create columns.
   */
  readonly columns: ColumnDef<T>[];

  /**
   * Enables pagination, mostly follows:
   * https://tanstack.com/table/v8/docs/api/features/pagination
   *
   */
  readonly pagination?: PaginationType;

  /**
   * Enables sorting, mostly follows:
   * https://tanstack.com/table/v8/docs/api/features/sorting#table-options
   *
   */
  readonly sorting?: SortingType;

  /**
   * This will force the table to have the specified hight
   *
   */
  readonly height?: number;
  /**
   * When set to true makes the header sticky while scrolling vertically
   *
   */
  readonly stickyHeader?: boolean;

  /**
   * Pins the firstColumn when scrolling horizontally
   *
   */
  readonly pinFirstColumn?: boolean;

  /**
   * Enables row click action. The provided callback will be executed when the row is clicked.
   */
  readonly onRowClick?: (row: Row<T>) => void;

  /**
   * The elements to display when the data table is empty
   */
  readonly emptyState?: ReactNode | ReactNode[];

  /**
   * When true, shows the loading state of the DataTable
   */
  readonly loading?: boolean;
}

export function DataTable<T extends object>({
  data,
  columns,
  pagination,
  sorting,
  height,
  stickyHeader,
  pinFirstColumn,
  onRowClick,
  emptyState,
  loading = false,
}: DataTableProps<T>) {
  const [ref, { exactWidth }] = useResizeObserver<HTMLDivElement>();
  const tableSettings = createTableSettings(data, columns, {
    pagination,
    sorting,
  });

  const tableClasses = classNames(styles.table, {
    [styles.pinFirstColumn]: pinFirstColumn,
  });

  const table = useReactTable(tableSettings);

  return (
    <div className={styles.dataTableContainer}>
      <div
        data-testid="ATL-DataTable-Container"
        className={styles.tableContainer}
        style={{ height }}
        ref={ref as LegacyRef<HTMLDivElement> | undefined}
      >
        <table className={tableClasses}>
          <Header
            table={table}
            sorting={sorting}
            onRowClick={onRowClick}
            stickyHeader={stickyHeader}
          />
          <Body
            table={table}
            onRowClick={onRowClick}
            emptyState={emptyState}
            loading={loading}
          />
          {table.getRowModel().rows.length &&
          exactWidth &&
          exactWidth > Breakpoints.small ? (
            <Footer table={table} viewType="desktop" />
          ) : null}
        </table>
      </div>
      {table.getRowModel().rows.length &&
      exactWidth &&
      exactWidth <= Breakpoints.small ? (
        <Footer table={table} />
      ) : null}

      {pagination && (
        <Pagination
          table={table}
          itemsPerPage={pagination.itemsPerPage}
          totalItems={
            pagination.manualPagination
              ? pagination.totalItems
              : table.getCoreRowModel().rows.length
          }
          loading={loading}
          onPageChange={() => ref.current?.scrollTo(0, 0)}
        />
      )}
    </div>
  );
}

DataTable.Table = DataTableTable;
DataTable.Header = DataTableHeader;
DataTable.HeaderCell = DataTableHeaderCell;
DataTable.Row = DataTableRow;
DataTable.Cell = DataTableCell;
DataTable.RowActions = DataTableRowActions;
DataTable.Actions = DataTableActions;
DataTable.Body = DataTableBody;
DataTable.Container = DataTableContainer;
DataTable.SortableHeader = DataTableSortableHeader;
DataTable.Footer = DataTableFooter;
DataTable.Pagination = DataTablePagination;
DataTable.PaginationButton = DataTablePaginationButton;
import React from "react";
import type { Table } from "@tanstack/react-table";
import { flexRender } from "@tanstack/react-table";
import styles from "./Footer.module.css";

export type ViewType = "desktop" | "handheld";

export interface FooterProps<T> {
  readonly table: Table<T>;
  readonly viewType?: ViewType;
}

interface ViewProps<T> {
  readonly table: Table<T>;
}

const DesktopView = <T extends object>({ table }: ViewProps<T>) => (
  <tfoot data-testid="data-table-desktop-footer">
    {table.getFooterGroups().map(footerGroup => (
      <tr key={footerGroup.id}>
        {footerGroup.headers.map(header => (
          <th
            key={header.id}
            style={{
              width: header.getSize(),
              minWidth: header.column.columnDef.minSize,
              maxWidth: header.column.columnDef.maxSize,
            }}
          >
            {flexRender(header.column.columnDef.footer, header.getContext())}
          </th>
        ))}
      </tr>
    ))}
  </tfoot>
);

const HandheldView = <T extends object>({ table }: ViewProps<T>) => (
  <div
    className={styles.mobileFooterContainer}
    data-testid="data-table-handheld-footer"
  >
    {table.getFooterGroups().map(footerGroup => (
      <div key={footerGroup.id}>
        {footerGroup.headers
          .filter(header => header.column.columnDef.footer)
          .map((header, index) => (
            <>
              {index === 0 ? (
                <div className={styles.mobileFooterRow}>
                  {flexRender(
                    header.column.columnDef.footer,
                    header.getContext(),
                  )}
                </div>
              ) : (
                <div className={styles.mobileFooterRow} key={footerGroup.id}>
                  {flexRender(
                    header.column.columnDef.header,
                    header.getContext(),
                  )}
                  <div className={styles.mobileFooterRowData}>
                    {flexRender(
                      header.column.columnDef.footer,
                      header.getContext(),
                    )}
                  </div>
                </div>
              )}
            </>
          ))}
      </div>
    ))}
  </div>
);

export const Footer = <T extends object>({
  table,
  viewType = "handheld",
}: FooterProps<T>) => {
  const hasFooter = table
    .getAllColumns()
    .find(column => column.columnDef.footer);

  if (hasFooter) {
    return viewType === "handheld" ? (
      <HandheldView table={table} />
    ) : (
      <DesktopView table={table} />
    );
  }

  return null;
};
import type { Row, Table } from "@tanstack/react-table";
import { flexRender } from "@tanstack/react-table";
import classNames from "classnames";
import React from "react";
import { SortDirection, SortIcon } from "./SortIcon";
import styles from "./DataTable.module.css";
import type { SortingType } from "./types";

interface HeaderProps<T> {
  readonly table: Table<T>;
  readonly stickyHeader?: boolean;
  readonly sorting?: SortingType;
  readonly onRowClick?: (row: Row<T>) => void;
}

export function Header<T extends object>({
  table,
  stickyHeader,
  sorting,
  onRowClick,
}: HeaderProps<T>) {
  const stickyClass = classNames({ [styles.stickyHeader]: stickyHeader });

  return (
    <thead className={stickyClass}>
      {table.getHeaderGroups().map(headerGroup => (
        <tr key={headerGroup.id}>
          {headerGroup.headers.map(header => {
            const isSorting = sorting && header.column.getCanSort();
            const headingCellInlineStyle: React.CSSProperties = {
              width: header.getSize(),
              minWidth: header.column.columnDef.minSize,
              maxWidth: header.column.columnDef.maxSize,
            };

            if (isSorting) {
              headingCellInlineStyle.paddingRight = 0;
            }

            return (
              <th
                key={header.id}
                colSpan={header.colSpan}
                className={
                  isSorting
                    ? classNames(styles.sortableColumn, {
                        [styles.pinFirstHeaderSortable]: !!onRowClick,
                      })
                    : ""
                }
                onClick={
                  sorting ? header.column.getToggleSortingHandler() : undefined
                }
                style={headingCellInlineStyle}
              >
                {header.isPlaceholder ? null : (
                  <div>
                    {flexRender(
                      header.column.columnDef.header,
                      header.getContext(),
                    )}
                    {header.column.getCanSort() &&
                      sorting &&
                      !header.column.getIsSorted() && (
                        <SortIcon direction={SortDirection.equilibrium} />
                      )}
                    {
                      {
                        asc: <SortIcon direction={SortDirection.ascending} />,
                        desc: <SortIcon direction={SortDirection.descending} />,
                      }[header.column.getIsSorted() as string]
                    }
                  </div>
                )}
              </th>
            );
          })}
        </tr>
      ))}
    </thead>
  );
}
import type { Table } from "@tanstack/react-table";
import React, { useMemo } from "react";
import styles from "./Pagination.module.css";
import { Option, Select } from "../Select";
import { Button } from "../Button";
import { Text } from "../Text";
import { Glimmer } from "../Glimmer";

interface PaginationProps<T> {
  readonly table: Table<T>;
  readonly itemsPerPage?: number[];
  readonly totalItems: number;
  readonly loading: boolean;
  readonly onPageChange: () => void;
}

const defaultItemsPerPageOptions = ["10", "20", "30", "40", "50"];

export function Pagination<T extends object>({
  table,
  itemsPerPage,
  totalItems,
  loading,
  onPageChange,
}: PaginationProps<T>) {
  const { pageIndex, pageSize } = table.getState().pagination;
  const totalRows = totalItems;
  const firstPosition = pageIndex * pageSize + 1;
  const secondPosition = Math.min(totalRows, pageSize * (pageIndex + 1));

  const itemsPerPageOptions = useMemo(
    () => itemsPerPage?.map(item => String(item)) ?? defaultItemsPerPageOptions,
    [itemsPerPage],
  );

  return secondPosition <= 0 ? (
    <div className={styles.pagination}>
      <div className={styles.paginationInfo}>
        {!loading ? <Text>No items</Text> : <Glimmer width={200} />}
      </div>
    </div>
  ) : (
    <div className={styles.pagination}>
      <div className={styles.paginationInfo}>
        {`Showing ${firstPosition}-${secondPosition} of ${totalRows} items`}
      </div>
      <div className={styles.paginationNav}>
        <div className={styles.paginationSelect}>
          <Select
            value={table.getState().pagination.pageSize}
            onChange={value => {
              table.setPageSize(Number(value));
            }}
            size="small"
          >
            {itemsPerPageOptions.map(numOfPages => (
              <Option key={numOfPages} value={numOfPages}>
                {numOfPages}
              </Option>
            ))}
          </Select>
          <span className={styles.paginationSelectLabel}>per page</span>
        </div>
        <div className={styles.paginationButtons}>
          <Button
            type="secondary"
            variation="subtle"
            icon="arrowLeft"
            ariaLabel="arrowLeft"
            onClick={() => {
              table.previousPage();
              onPageChange();
            }}
            disabled={!table.getCanPreviousPage()}
          />
          <Button
            type="secondary"
            variation="subtle"
            icon="arrowRight"
            ariaLabel="arrowRight"
            onClick={() => {
              table.nextPage();
              onPageChange();
            }}
            disabled={!table.getCanNextPage()}
          />
        </div>
      </div>
    </div>
  );
}
import classNames from "classnames";
import React from "react";
import styles from "./SortIcon.module.css";

export enum SortDirection {
  ascending,
  descending,
  equilibrium,
}

const sortStyleIndex = [
  {
    option: SortDirection.equilibrium,
    upArrowStyle: undefined,
    downArrowStyle: undefined,
  },
  {
    option: SortDirection.ascending,
    upArrowStyle: classNames(styles.active),
    downArrowStyle: classNames(styles.inactive),
  },
  {
    option: SortDirection.descending,
    upArrowStyle: classNames(styles.inactive),
    downArrowStyle: classNames(styles.active),
  },
];

interface SortIconProps {
  readonly direction: SortDirection;
}

export function SortIcon({ direction }: SortIconProps): JSX.Element {
  const foundStyle = sortStyleIndex.find(style => style.option === direction);
  const finalStyle = foundStyle === undefined ? sortStyleIndex[0] : foundStyle;

  return (
    <div className={classNames(styles.sortIcon)}>
      <svg
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          className={finalStyle.upArrowStyle}
          d="M16.2929 10.6661C15.9024 11.0566 15.2692 11.0566 14.8787 10.6661L12.2891 8.14263L9.70711 10.6661C9.31658 11.0566 8.68342 11.0566 8.29289 10.6661C7.90237 10.2756 7.90237 9.64239 8.29289 9.25186L11.5858 5.95897C11.9763 5.56845 12.6095 5.56845 13 5.95897L16.2929 9.25186C16.6834 9.64239 16.6834 10.2756 16.2929 10.6661Z"
        />
        <path
          className={finalStyle.downArrowStyle}
          d="M8.29292 13.3339C8.68345 12.9434 9.31661 12.9434 9.70714 13.3339L12.2968 15.8573L14.8787 13.3339C15.2692 12.9434 15.9024 12.9434 16.2929 13.3339C16.6834 13.7244 16.6834 14.3576 16.2929 14.7481L13 18.041C12.6095 18.4315 11.9763 18.4315 11.5858 18.041L8.29292 14.7481C7.9024 14.3576 7.9024 13.7244 8.29292 13.3339Z"
        />
      </svg>
    </div>
  );
}

```

## Props

### Web Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `data` | `T[]` | ✅ | `_none_` | The actual data that will be used for the table.
Typescript should infer T from typeof data. |
| `columns` | `ColumnDef<T>[]` | ✅ | `_none_` | Should follow the
@tanstack /react-table [ColumnDef](https://tanstack.com/table/v8/docs/guide/column-defs).
[createColumnHelper](https://tanstack.com/table/v8/docs/guide/column-defs#column-helpers) is also exposed to make it more convenient
to create columns. |
| `pagination` | `PaginationType` | ❌ | `_none_` | Enables pagination, mostly follows:
https://tanstack.com/table/v8/docs/api/features/pagination |
| `sorting` | `SortingType` | ❌ | `_none_` | Enables sorting, mostly follows:
https://tanstack.com/table/v8/docs/api/features/sorting#table-options |
| `height` | `number` | ❌ | `_none_` | This will force the table to have the specified hight |
| `stickyHeader` | `boolean` | ❌ | `_none_` | When set to true makes the header sticky while scrolling vertically |
| `pinFirstColumn` | `boolean` | ❌ | `_none_` | Pins the firstColumn when scrolling horizontally |
| `onRowClick` | `(row: Row<T>) => void` | ❌ | `_none_` | Enables row click action. The provided callback will be executed when the row is clicked. |
| `emptyState` | `ReactNode | ReactNode[]` | ❌ | `_none_` | The elements to display when the data table is empty |
| `loading` | `boolean` | ❌ | `[object Object]` | When true, shows the loading state of the DataTable |


## Categories

- Lists & Tables

## Web Test Code

```typescript
DataTable Thicklist Table Web React Test Testing Jest import React from "react";
import { fireEvent, render, screen, within } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { DataTable } from "./DataTable";
import {
  columSizeColumns,
  columnSizeData,
  columns,
  data,
  mockContainerWidth,
  royaltyReportColumns,
  royaltyReportData,
} from "./test-utilities";
import { GLIMMER_TEST_ID } from "../Glimmer";

// Allow us to mock and replace the value of useResizeObserver would return via
// a spy
// https://stackoverflow.com/a/72885576
jest.mock("@jobber/hooks/useResizeObserver", () => {
  return {
    __esModule: true, //    <----- this __esModule: true is important
    ...(jest.requireActual("@jobber/hooks/useResizeObserver") as object),
  };
});

describe("when rendering a Basic Table", () => {
  beforeEach(() => {
    render(<DataTable data={data} columns={columns} />);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it("renders all headers", () => {
    const tableHeader = screen.getAllByRole("row")[0];

    expect(within(tableHeader).getByText(/Name/i)).toBeInTheDocument();
    expect(within(tableHeader).getByText(/House/i)).toBeInTheDocument();
    expect(within(tableHeader).getByText(/Region/i)).toBeInTheDocument();
    expect(within(tableHeader).getByText(/Sigil/i)).toBeInTheDocument();
    expect(within(tableHeader).getByText(/Alive/i)).toBeInTheDocument();
  });

  it("renders all rows", () => {
    const [, ...bodyRows] = screen.getAllByRole("row");

    expect(bodyRows).toHaveLength(data.length);
  });
});

describe("when using pagination", () => {
  const scrollToMock = jest.fn();
  beforeEach(() => {
    render(
      <DataTable
        data={data}
        columns={columns}
        pagination={{ manualPagination: false, itemsPerPage: [5, 10, 15] }}
      />,
    );
    const tableContainer = screen.getByTestId("ATL-DataTable-Container");
    tableContainer.scrollTo = scrollToMock;
  });

  it("renders table with pagination info", () => {
    const paginationInfo = screen.getByText(/Showing 1-5 of 13 items/i);
    expect(paginationInfo).toBeInTheDocument();
  });

  it("renders the correct number of rows", () => {
    const [, ...bodyRows] = screen.getAllByRole("row");

    expect(bodyRows).toHaveLength(5);
  });

  it("renders previous page button disabled on the first page", () => {
    expect(screen.getByLabelText("arrowLeft")).toBeDisabled();
  });

  it("resets scroll when navigating between next and previous page", async () => {
    const arrowRight = screen.getByTestId("arrowRight");
    await userEvent.click(arrowRight);
    expect(scrollToMock).toHaveBeenCalledWith(0, 0);

    const arrowLeft = screen.getByTestId("arrowLeft");
    await userEvent.click(arrowLeft);
    expect(scrollToMock).toHaveBeenCalledWith(0, 0);
  });

  it("renders updated pagination info of the next page", async () => {
    const arrowRight = screen.getByTestId("arrowRight");
    await userEvent.click(arrowRight);

    const paginationInfo = screen.getByText(/Showing 6-10 of 13 items/i);
    expect(paginationInfo).toBeInTheDocument();
  });

  it("renders correct number of rows of the next page and previous page", async () => {
    const arrowRight = screen.getByTestId("arrowRight");
    await userEvent.click(arrowRight);

    const [, ...bodyRowsPage2] = screen.getAllByRole("row");
    expect(bodyRowsPage2).toHaveLength(5);

    await userEvent.click(arrowRight);

    const [, ...bodyRowsPage3] = screen.getAllByRole("row");
    expect(bodyRowsPage3).toHaveLength(3);

    await userEvent.click(screen.getByTestId("arrowLeft"));

    const [, ...bodyRowsFinalPage] = screen.getAllByRole("row");
    expect(bodyRowsFinalPage).toHaveLength(5);
  });

  it("renders correctly after per page change", async () => {
    const select = screen.getByRole("combobox");
    const selectedOption1 = "10";

    fireEvent.change(select, {
      target: { value: selectedOption1 },
    });

    const [, ...bodyRows] = screen.getAllByRole("row");

    expect(bodyRows).toHaveLength(10);

    const selectedOption2 = "15";

    fireEvent.change(select, {
      target: { value: selectedOption2 },
    });

    const [, ...bodyRowsUpdated] = screen.getAllByRole("row");
    expect(bodyRowsUpdated).toHaveLength(13);
  });
});

describe("when using manual pagination", () => {
  const mockedOnPaginationChange = jest.fn();
  const scrollToMock = jest.fn();
  const state = { pageIndex: 0, pageSize: 10 };
  const totalItems = 13;
  beforeEach(() => {
    render(
      <DataTable
        data={data}
        columns={columns}
        pagination={{
          manualPagination: true,
          state,
          onPaginationChange: mockedOnPaginationChange,
          pageCount: Math.ceil(totalItems / state.pageSize),
          totalItems,
        }}
      />,
    );
    const tableContainer = screen.getByTestId("ATL-DataTable-Container");
    tableContainer.scrollTo = scrollToMock;
  });
  it("calls the provided callback", async () => {
    await userEvent.click(screen.getByLabelText("arrowRight"));

    expect(mockedOnPaginationChange).toHaveBeenCalledTimes(1);
  });
});

describe("when using sorting", () => {
  it("renders table with clickable headers", async () => {
    render(
      <DataTable
        data={data}
        columns={columns}
        sorting={{ manualSorting: false }}
      />,
    );
    const nameHeader = screen.getByText("Name");

    await userEvent.click(nameHeader); // sort to asc

    const firstBodyRow = screen.getAllByRole("row")[1];
    expect(within(firstBodyRow).getByText("Arya")).toBeInTheDocument();

    await userEvent.click(nameHeader); // sort to desc

    const firstBodyRowUpdated = screen.getAllByRole("row")[1];
    expect(within(firstBodyRowUpdated).getByText("Tommen")).toBeInTheDocument();
  });
});

describe("when using manual sorting", () => {
  const mockedOnSortingChange = jest.fn();

  it("calls the provided callback", async () => {
    render(
      <DataTable
        data={data}
        columns={columns}
        sorting={{
          manualSorting: true,
          state: [],
          onSortingChange: mockedOnSortingChange,
        }}
      />,
    );

    const nameHeader = screen.getByText("Name");

    await userEvent.click(nameHeader);

    expect(mockedOnSortingChange).toHaveBeenCalledTimes(1);
  });
});

describe("when using onRowClick", () => {
  const clickHandler = jest.fn();
  beforeEach(() => {
    render(
      <DataTable data={data} columns={columns} onRowClick={clickHandler} />,
    );
  });

  it("Executes a callback function", async () => {
    const firstBodyRow = screen.getAllByRole("row")[1];
    await userEvent.click(firstBodyRow);
    expect(clickHandler).toHaveBeenCalledTimes(1);
  });
});

describe("when using the column footers", () => {
  beforeEach(() => {
    mockContainerWidth();
    render(
      <DataTable data={royaltyReportData} columns={royaltyReportColumns} />,
    );
  });

  it("renders the footer row with the totals", () => {
    const totalsRowTitle = screen.getByText("Report Totals ($)");
    const totalsRowFirstData = screen.getByText("10,050,400");
    const totalsRowSecondData = screen.getByText("300,000");

    expect(totalsRowTitle).toBeDefined();
    expect(totalsRowFirstData).toBeDefined();
    expect(totalsRowSecondData).toBeDefined();
  });

  describe("when the table has a width > 500px", () => {
    it("renders the footer desktop view", () => {
      const totalsRow = screen.getByTestId("data-table-desktop-footer");

      expect(totalsRow).toBeDefined();
    });
  });

  describe("when the table has a width <= 500px", () => {
    beforeEach(() => {
      mockContainerWidth(499);
      render(
        <DataTable data={royaltyReportData} columns={royaltyReportColumns} />,
      );
    });

    it("renders the footer handheld view", () => {
      const totalsRow = screen.getByTestId("data-table-handheld-footer");

      expect(totalsRow).toBeDefined();
    });
  });
});

describe("when using manual column sizing", () => {
  beforeEach(() => {
    render(<DataTable data={columnSizeData} columns={columSizeColumns} />);
  });

  it("applies the defined widths to headers", () => {
    const firstHeader = screen.getAllByRole("columnheader")[0];

    expect(firstHeader.style.width).toBe("538px");
    expect(firstHeader.style.minWidth).toBe("438px");
    expect(firstHeader.style.maxWidth).toBe("538px");
  });

  it("applies the defined widths to cells", () => {
    const firstCell = screen.getAllByRole("cell")[0];

    expect(firstCell.style.width).toBe("538px");
    expect(firstCell.style.minWidth).toBe("438px");
    expect(firstCell.style.maxWidth).toBe("538px");
  });
});

describe("when the table has no data", () => {
  beforeEach(() => {
    render(
      <DataTable
        data={[]}
        columns={columSizeColumns}
        emptyState={<p>No data</p>}
      />,
    );
  });

  it("renders the provided empty state", () => {
    expect(screen.getByText("No data")).toBeDefined();
  });
});

describe("when the table has a loading prop set to true", () => {
  it("Shows the default amount of loaders for each column", async () => {
    render(
      <DataTable
        data={[]}
        pagination={{ manualPagination: false }}
        columns={royaltyReportColumns}
        loading={true}
      />,
    );
    expect(await screen.findAllByTestId(GLIMMER_TEST_ID)).toHaveLength(41);
  });

  it("Shows the amount of loaders based on smallest items per page value", async () => {
    render(
      <DataTable
        data={[]}
        pagination={{ manualPagination: false, itemsPerPage: [20, 30, 40] }}
        columns={royaltyReportColumns}
        loading={true}
      />,
    );
    expect(await screen.findAllByTestId(GLIMMER_TEST_ID)).toHaveLength(81);
  });
});
import React from "react";
import { render } from "@testing-library/react";
import { SortDirection, SortIcon } from "./SortIcon";

describe("SortIcon", () => {
  describe("when direction is equilibrium", () => {
    it("renders with no active classes", () => {
      render(<SortIcon direction={SortDirection.equilibrium} />);

      const svg = document.querySelector("svg");
      expect(svg).toBeInTheDocument();

      const upArrow = svg?.querySelector("path:first-child");
      const downArrow = svg?.querySelector("path:last-child");

      expect(upArrow).not.toHaveClass("active");
      expect(upArrow).not.toHaveClass("inactive");
      expect(downArrow).not.toHaveClass("active");
      expect(downArrow).not.toHaveClass("inactive");
    });
  });

  describe("when direction is ascending", () => {
    it("renders with up arrow active and down arrow inactive", () => {
      render(<SortIcon direction={SortDirection.ascending} />);

      const svg = document.querySelector("svg");
      expect(svg).toBeInTheDocument();

      const upArrow = svg?.querySelector("path:first-child");
      const downArrow = svg?.querySelector("path:last-child");

      expect(upArrow).toHaveClass("active");
      expect(downArrow).toHaveClass("inactive");
    });
  });

  describe("when direction is descending", () => {
    it("renders with down arrow active and up arrow inactive", () => {
      render(<SortIcon direction={SortDirection.descending} />);

      const svg = document.querySelector("svg");
      expect(svg).toBeInTheDocument();

      const upArrow = svg?.querySelector("path:first-child");
      const downArrow = svg?.querySelector("path:last-child");

      expect(upArrow).toHaveClass("inactive");
      expect(downArrow).toHaveClass("active");
    });
  });

  describe("SVG structure", () => {
    it("renders two path elements", () => {
      render(<SortIcon direction={SortDirection.ascending} />);

      const svg = document.querySelector("svg");
      const paths = svg?.querySelectorAll("path");
      expect(paths).toHaveLength(2);
    });
  });

  describe("container styling", () => {
    it("renders with sortIcon class", () => {
      render(<SortIcon direction={SortDirection.ascending} />);

      const container = document.querySelector(".sortIcon");
      expect(container).toBeInTheDocument();
    });
  });
});

```

## Component Path

`/components/DataTable`

---

_Generated on 2025-08-21T17:35:16.358Z_
