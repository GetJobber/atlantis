# AtlantisThemeContext

<Meta
  title="Components/Themes/AtlantisThemeContext"
  component={AtlantisThemeContextProvider}
/>

# AtlantisThemeContext

Provides a way to control the theme of Atlantis components and the design
tokens.

## Design & usage guidelines

Both the web and mobile components have the exact same API, except for one minor
difference in how you update the theme.

Each platform provides a `useAtlantisTheme` hook that you may use to access the
`theme` and `tokens` in your components.

On mobile, this hook also returns a `setTheme` function which you'll use to
update the theme for the nearest `AtlantisThemeContextProvider` ancestor.
Typically there will only be a single provider at the root, controlling the
theme for the entire app.

On web, you'll need to import the `updateTheme` function and call it with the
new theme. This is a separate function because it synchronizes the theme update
across all providers under various React trees. Synchronizing across providers
is necessary for cases where an island-based architecture is used.

### Usage for web

```tsx
import {
  AtlantisThemeContextProvider,
  updateTheme,
  useAtlantisTheme,
} from "@jobber/components/AtlantisThemeContext";

function App() {
  return (
    <AtlantisThemeContextProvider>
      <ThemedComponent />
    </AtlantisThemeContextProvider>
  );
}

function ThemedComponent() {
  const { theme, tokens } = useAtlantisTheme();
  return (
    <Content>
      <div
        style={{
          background: tokens["surface-background"],
          padding: tokens["space-base"],
        }}
      >
        <Content>
          <Text>The current theme is: {theme}.</Text>
          <Text>
            The javascript tokens can be accessed via the tokens object.
          </Text>
          <Text>The theme can be changed using `updateTheme`</Text>
          <Button
            onClick={() => updateTheme("light")}
            label="The theme can be changed to light"
          />
          <Button
            onClick={() => updateTheme("dark")}
            label="The theme can be changed to dark"
          />
        </Content>
      </div>
    </Content>
  );
}
```

### Usage for mobile

```tsx
import {
  AtlantisThemeContextProvider,
  useAtlantisTheme,
} from "@jobber/components/AtlantisThemeContext";

function App() {
  return (
    <AtlantisThemeContextProvider>
      <ThemedComponent />
    </AtlantisThemeContextProvider>
  );
}

function ThemedComponent() {
  const { theme, tokens, setTheme } = useAtlantisTheme();
  return (
    <Content>
      <View
        style={{
          background: tokens["surface-background"],
          padding: tokens["space-base"],
        }}
      >
        <Content>
          <Text>The current theme is: {theme}.</Text>
          <Text>
            The javascript tokens can be accessed via the tokens object.
          </Text>
          <Text>The theme can be changed using `setTheme`</Text>
          <Button
            onPress={() => setTheme("light")}
            label="The theme can be changed to light"
          />
          <Button
            onPress={() => setTheme("dark")}
            label="The theme can be changed to dark"
          />
        </Content>
      </View>
    </Content>
  );
}
```

### Forcing a theme for an AtlantisThemeContextProvider

In some scenarios you may want to force a theme for specific components
regardless of the main application theme. This can be done by setting the
`dangerouslyOverrideTheme` prop to `<themeToSet>` on the
`AtlantisThemeContextProvider`.

```tsx
import {
  AtlantisThemeContextProvider,
  updateTheme,
  useAtlantisTheme,
} from "@jobber/components/AtlantisThemeContext";

function App() {
  return (
    <AtlantisThemeContextProvider>
      <ThemedComponent />
      <AtlantisThemeContextProvider dangerouslyOverrideTheme="dark">
        <Text>These components will always be dark themed</Text>
        <ThemedComponent />
      </AtlantisThemeContextProvider>
    </AtlantisThemeContextProvider>
  );
}

function ThemedComponent() {
  const { theme, tokens } = useAtlantisTheme();
  return (
    <Content>
      <div
        style={{
          background: tokens["surface-background"],
          padding: tokens["space-base"],
        }}
      >
        <Content>
          <Text>The current theme is: {theme}. </Text>
          <Text>
            The javascript tokens can be accessed via the tokens object.
          </Text>
          <Text>The theme can be changed using `updateTheme`</Text>
          <Button
            onClick={() => updateTheme("light")}
            label="The theme can be changed to light"
          />
          <Button
            onClick={() => updateTheme("dark")}
            label="The theme can be changed to dark"
          />
        </Content>
      </div>
    </Content>
  );
}
```

### Creating themed styles with buildThemedStyles (Mobile Only)

The `buildThemedStyles` utility is available to help create themed StyleSheets
that automatically update when the theme changes.

```tsx
// In the .style.ts file

const useStyles = buildThemedStyles(tokens => ({
  container: {
    backgroundColor: tokens["color-surface"],
    padding: tokens["space-base"],
    borderRadius: tokens["radius-base"],
  },
  text: {
    color: tokens["color-text"],
    fontSize: tokens["font-size-base"],
  },
}));

// In the component file
function ThemedComponent() {
  const styles = useStyles();
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Themed content</Text>
    </View>
  );
}
```

Key features:

- Automatically updates styles when the theme changes
- Works with React Native's StyleSheet system
- Memoized so that the StyleSheet is only re-created when the theme changes

## Web Component Code

```tsx
AtlantisThemeContext Theme Dark Mode Light Mode Web React import { darkTokens, tokens } from "@jobber/design";
import type { PropsWithChildren } from "react";
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useState,
} from "react";
import merge from "lodash/merge";
import type {
  AtlantisThemeContextProviderProps,
  AtlantisThemeContextValue,
  Theme,
  ThemeChangeDetails,
} from "./types";
import { THEME_CHANGE_EVENT } from "./types";
import styles from "./AtlantisThemeContext.module.css";

export const atlantisThemeContextDefaultValues: AtlantisThemeContextValue = {
  theme: "light",
  tokens: tokens,
};

const actualDarkTokens = merge({}, tokens, darkTokens);

const AtlantisThemeContext = createContext(atlantisThemeContextDefaultValues);

export function AtlantisThemeContextProvider({
  children,
  dangerouslyOverrideTheme,
}: AtlantisThemeContextProviderProps) {
  if (dangerouslyOverrideTheme) {
    return (
      <InternalStaticThemeProvider
        dangerouslyOverrideTheme={dangerouslyOverrideTheme}
      >
        {children}
      </InternalStaticThemeProvider>
    );
  }

  return (
    <InternalDynamicThemeProvider>{children}</InternalDynamicThemeProvider>
  );
}

function InternalDynamicThemeProvider({ children }: PropsWithChildren) {
  const initialTheme: Theme =
    (globalThis.document.documentElement.dataset.theme as Theme) ?? "light";

  const [internalTheme, setInternalTheme] = useState<Theme>(initialTheme);
  const currentTokens = internalTheme === "dark" ? actualDarkTokens : tokens;

  const handleThemeChangeEvent = useCallback((event: Event) => {
    const newTheme = (event as CustomEvent<ThemeChangeDetails>).detail.theme;
    setInternalTheme(newTheme);
  }, []);

  useEffect(() => {
    if (!globalThis.window) return;
    globalThis.window.addEventListener(
      THEME_CHANGE_EVENT,
      handleThemeChangeEvent,
    );

    return () => {
      globalThis.window.removeEventListener(
        THEME_CHANGE_EVENT,
        handleThemeChangeEvent,
      );
    };
  }, [handleThemeChangeEvent]);

  return (
    <AtlantisThemeContext.Provider
      value={{
        theme: internalTheme,
        tokens: currentTokens,
      }}
    >
      {children}
    </AtlantisThemeContext.Provider>
  );
}

function InternalStaticThemeProvider({
  dangerouslyOverrideTheme,
  children,
}: Required<
  Pick<
    AtlantisThemeContextProviderProps,
    "dangerouslyOverrideTheme" | "children"
  >
>) {
  const currentTokens =
    dangerouslyOverrideTheme === "dark" ? actualDarkTokens : tokens;

  return (
    <AtlantisThemeContext.Provider
      value={{
        theme: dangerouslyOverrideTheme,
        tokens: currentTokens,
      }}
    >
      <div
        data-theme={dangerouslyOverrideTheme}
        className={styles.staticThemeProviderWrapper}
      >
        {children}
      </div>
    </AtlantisThemeContext.Provider>
  );
}

export function useAtlantisTheme() {
  return useContext(AtlantisThemeContext);
}

```

## Props

### Web Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `children` | `ReactNode` | ✅ | `_none_` | The children to render. |
| `dangerouslyOverrideTheme` | `Theme` | ❌ | `_none_` | Force the theme for this provider to always be the same as the provided theme. Useful for sections that should remain the same theme regardless of the rest of the application's theme.
This is dangerous because the children in this provider will not be able to change the theme. |


### Mobile Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `children` | `ReactNode` | ✅ | `_none_` | The children to render. |
| `dangerouslyOverrideTheme` | `Theme` | ❌ | `_none_` | Force the theme for this provider to always be the same as the provided theme. Useful for sections that should remain the same theme regardless of the rest of the application's theme.
This is dangerous because the children in this provider will not be able to change the theme. |


## Categories

- Themes

## Web Test Code

```typescript
AtlantisThemeContext Theme Dark Mode Light Mode Web React Test Testing Jest import React from "react";
import { act, renderHook, screen } from "@testing-library/react";
import { darkTokens, webTokens } from "@jobber/design";
import merge from "lodash/merge";
import {
  AtlantisThemeContextProvider,
  useAtlantisTheme,
} from "./AtlantisThemeContext";
import type { AtlantisThemeContextProviderProps, Theme } from "./types";
import { updateTheme } from "./updateTheme";
import { InlineLabel } from "../InlineLabel";

const expectedDarkTokens = merge({}, webTokens, darkTokens);
const expectedLightTokens = webTokens;

describe("ThemeContext", () => {
  function TestWrapper({
    children,
    dangerouslyOverrideTheme,
  }: AtlantisThemeContextProviderProps) {
    return (
      <div data-testid="test-wrapper">
        <AtlantisThemeContextProvider
          dangerouslyOverrideTheme={dangerouslyOverrideTheme}
        >
          <InlineLabel color="red">Past due</InlineLabel>
          {children}
        </AtlantisThemeContextProvider>
      </div>
    );
  }
  describe("when the theme is already set on the root element", () => {
    afterAll(() => {
      delete globalThis.document.documentElement.dataset.theme;
    });

    it("should use the theme already set", () => {
      globalThis.document.documentElement.dataset.theme = "dark";

      const results = renderHook(useAtlantisTheme, {
        wrapper: (props: AtlantisThemeContextProviderProps) => (
          <TestWrapper {...props} />
        ),
      });

      expect(results.result.current.theme).toBe("dark");
      expect(results.result.current.tokens).toEqual(expectedDarkTokens);
    });
  });

  describe("when the theme is not set on the root element", () => {
    it("should use the light theme theme", () => {
      const results = renderHook(useAtlantisTheme, {
        wrapper: (props: AtlantisThemeContextProviderProps) => (
          <TestWrapper {...props} />
        ),
      });

      expect(results.result.current.theme).toBe("light");
      expect(results.result.current.tokens).toEqual(expectedLightTokens);
    });
  });

  it("should update the theme and tokens", () => {
    const results = renderHook(useAtlantisTheme, {
      wrapper: (props: AtlantisThemeContextProviderProps) => (
        <TestWrapper {...props} />
      ),
    });

    const rootHTMLElement =
      screen.getByTestId("test-wrapper").ownerDocument?.documentElement;

    act(() => updateTheme("dark"));

    expect(results.result.current.theme).toBe("dark");
    expect(results.result.current.tokens).toEqual(expectedDarkTokens);
    expect(rootHTMLElement?.dataset.theme).toBe("dark");

    act(() => updateTheme("light"));
    expect(results.result.current.theme).toBe("light");
    expect(results.result.current.tokens).toEqual(expectedLightTokens);
    expect(rootHTMLElement?.dataset.theme).toBe("light");
  });

  it("should update the theme and tokens for all theme providers", () => {
    const firstProvider = renderHook(useAtlantisTheme, {
      wrapper: (props: AtlantisThemeContextProviderProps) => (
        <TestWrapper {...props} />
      ),
    });
    const secondProvider = renderHook(useAtlantisTheme, {
      wrapper: (props: AtlantisThemeContextProviderProps) => (
        <TestWrapper {...props} />
      ),
    });

    act(() => updateTheme("dark"));

    expect(firstProvider.result.current.theme).toBe("dark");
    expect(firstProvider.result.current.tokens).toEqual(expectedDarkTokens);
    expect(secondProvider.result.current.theme).toBe("dark");
    expect(secondProvider.result.current.tokens).toEqual(expectedDarkTokens);
  });

  describe("when theme is forced for provider", () => {
    it("should add a data-theme attribute for the overriden theme to the wrapping element", () => {
      renderHook(useAtlantisTheme, {
        wrapper: (props: AtlantisThemeContextProviderProps) => (
          <TestWrapper {...props} dangerouslyOverrideTheme="dark" />
        ),
      });
      const wrapper = screen.getByTestId("test-wrapper");
      expect(wrapper.firstElementChild?.getAttribute("data-theme")).toEqual(
        "dark",
      );

      act(() => updateTheme("light"));

      expect(wrapper.firstElementChild?.getAttribute("data-theme")).toEqual(
        "dark",
      );
    });

    it("should not update the theme for other providers", () => {
      const firstProvider = renderHook(useAtlantisTheme, {
        wrapper: (props: AtlantisThemeContextProviderProps) => (
          <TestWrapper {...props} />
        ),
      });
      const secondProvider = renderHook(useAtlantisTheme, {
        wrapper: (props: AtlantisThemeContextProviderProps) => (
          <TestWrapper {...props} dangerouslyOverrideTheme="dark" />
        ),
      });

      expect(firstProvider.result.current.theme).toBe("light");
      expect(firstProvider.result.current.tokens).toEqual(expectedLightTokens);

      expect(secondProvider.result.current.theme).toBe("dark");
      expect(secondProvider.result.current.tokens).toEqual(expectedDarkTokens);
    });

    it("should ignore updates to the theme", () => {
      const results = renderHook(useAtlantisTheme, {
        wrapper: (props: AtlantisThemeContextProviderProps) => (
          <TestWrapper {...props} dangerouslyOverrideTheme="light" />
        ),
      });

      act(() => updateTheme("dark"));

      expect(results.result.current.theme).toBe("light");
      expect(results.result.current.tokens).toEqual(expectedLightTokens);
    });

    it.each([
      { defaultTheme: "light", expectedTokens: expectedLightTokens },
      { defaultTheme: "dark", expectedTokens: expectedDarkTokens },
    ] as { defaultTheme: Theme; expectedTokens: typeof webTokens }[])(
      "should provide the dangerouslyOverrideTheme $defaultTheme tokens",
      ({ defaultTheme, expectedTokens }) => {
        const results = renderHook(useAtlantisTheme, {
          wrapper: (props: AtlantisThemeContextProviderProps) => (
            <TestWrapper {...props} dangerouslyOverrideTheme={defaultTheme} />
          ),
        });

        const currentTheme = results.result.current.theme;
        const currentTokens = results.result.current.tokens;
        expect(currentTheme).toBe(defaultTheme);
        expect(currentTokens).toEqual(expectedTokens);
      },
    );
  });
});

```

## Component Path

`/components/AtlantisThemeContext`

---

_Generated on 2025-08-21T17:35:16.352Z_
