import { mkdirSync, writeFileSync } from "fs";
import { dirname } from "path";
import { parse } from "react-docgen-typescript";
import {
  ListOfGeneratedMobileComponents,
  ListOfGeneratedWebComponents,
} from "./baseComponentLists.mjs";

/**
 * This script is used to generate the *.props.json files under the src/content directory of this repo.
 *
 * The script uses react-docgen-typescript to parse our Typescript Component files, and generate a JSON representation that we can then
 * display to our consumers.
 *
 * These props can be parsed without the need for the library, but react-docgen-typescript a battle-tested approach that we don't
 * have to own. I believe the project is currently looking for a maintainer, and the community was/is pressuruing Storybook
 * to take it on, since it's a critical part of their system.
 *
 * These prop files are then used to generate the list of Props for every component on our documentation site.
 *
 */

/**
 * Take in a component location, and where you want the output written. We will parse the component contents at the provided location, and write the
 * associated JSON file in the provided output location.
 * @param {string} componentPath
 * @param {string} outputPath
 */
const parseAndWriteDocs = (componentPath, outputPath) => {
  console.log("parsing component at:", componentPath);
  const documentation = parse(componentPath);
  const cleanedDocumentation = removeNonComponents(
    removeDeclarations(documentation),
  );

  const outputDir = dirname(outputPath);
  mkdirSync(outputDir, { recursive: true });

  console.log("writing documentation to:", outputPath);
  writeFileSync(outputPath, JSON.stringify(cleanedDocumentation, null, 2));
};

/**
 * react-docgen-typescript parses every export from the component file, which
 * includes functions that are not components.
 *
 * This method filters out any items that start with a lowercase letter, which is almost always
 * non-component function exports.
 *
 * @param {object} doc
 * @returns The doc without any functions
 */
const removeNonComponents = doc => {
  doc = doc.filter(item => item.displayName.match(/^[A-Z]/));

  return doc;
};

/**
 * The 'declarations' field within the generated JSON output are all the instances where the prop is referenced. Normally it's a single field, maybe two.
 * In some of our components, we're making heavy use of the XOR operator to allow and disallow certain props from being used together.
 * When react-docgen-typescript generates the JSON, it includes every variation of these references which are not useful for our documentation site.
 * In the case of Button in particular, it generated thousands of lines of JSON that were not useful (outside of the signal that our props were too complicated, which we knew already).
 *
 * We use this small recursive method (generated by GPT) to remove all instances of 'declarations' from the JSON output.
 *
 * If there's a smarter way to do this, we're all ears! This was a quick solution that is easy to remove later if we just fix our XOR usages.
 *
 * It's possible this could be used as a signal to when our props are too complicated, but that's a different conversation.
 *
 * @param {JSON} doc
 * @returns JSON without any keys called 'declarations'
 */
const removeDeclarations = doc => {
  if (Array.isArray(doc)) {
    return doc.map(removeDeclarations);
  } else if (typeof doc === "object" && doc !== null) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { declarations, ...rest } = doc;

    return Object.keys(rest).reduce((acc, key) => {
      acc[key] = removeDeclarations(rest[key]);

      return acc;
    }, {});
  }

  return doc;
};

/**
 * Takes in 3 pieces of information (component directory, output directory, and componentname) and builds a standard path object from it.
 *
 * The pattern is currently to have a directory in the components directory that matches the component name.
 *
 * @param {string} baseComponentDir
 * @param {string} baseOutputDir
 * @param {string} componentName
 * @returns {{componentPath: string, outputPath: string}}
 */
const buildPaths = (
  baseComponentDir,
  baseOutputDir,
  componentName,
  tack = "",
) => {
  const componentPath = `${baseComponentDir}/${componentName}/${componentName}.tsx`;
  const outputPath = `${baseOutputDir}/${componentName}/${componentName}.props${tack}.json`;

  return { componentPath, outputPath };
};

/**
 * In a library world, these would be provided at run-time for more reusability but this script is hyper-specific for now.
 *
 * With these as relative paths, we also need to make sure we build from the correct location. An
 * improvement in the future would be take in the location of the script, and work from there instead (__dirname in the old world).
 */
const baseComponentDir = `../components/src`;
const baseMobileComponentDir = `../components-native/src`;
const baseOutputDir = "./src/content";

const buildComponentDocs = name => {
  const { componentPath, outputPath } = buildPaths(
    baseComponentDir,
    baseOutputDir,
    name,
  );
  parseAndWriteDocs(componentPath, outputPath);
};

const buildMobileComponentDocs = name => {
  const { componentPath, outputPath } = buildPaths(
    baseMobileComponentDir,
    baseOutputDir,
    name,
    "-mobile",
  );
  parseAndWriteDocs(componentPath, outputPath);
};

ListOfGeneratedWebComponents.forEach(buildComponentDocs);

ListOfGeneratedMobileComponents.forEach(buildMobileComponentDocs);
