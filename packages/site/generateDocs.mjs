import { existsSync, mkdirSync, writeFileSync } from "fs";
import { dirname } from "path";
import { parse } from "react-docgen-typescript";
import {
  ListOfGeneratedMobileComponents,
  ListOfGeneratedWebComponents,
} from "./baseComponentLists.mjs";

/**
 * This script is used to generate the *.props.json files under the src/content directory of this repo.
 *
 * The script uses react-docgen-typescript to parse our Typescript Component files, and generate a JSON representation that we can then
 * display to our consumers.
 *
 * These props can be parsed without the need for the library, but react-docgen-typescript a battle-tested approach that we don't
 * have to own. I believe the project is currently looking for a maintainer, and the community was/is pressuruing Storybook
 * to take it on, since it's a critical part of their system.
 *
 * These prop files are then used to generate the list of Props for every component on our documentation site.
 *
 */

/**
 * Take in a component location, and where you want the output written. We will parse the component contents at the provided location, and write the
 * associated JSON file in the provided output location.
 * @param {string} componentPath
 * @param {string} outputPath
 */
const parseAndWriteDocs = (componentPath, outputPath) => {
  console.log("parsing component at:", componentPath);
  const documentation = parse(componentPath);
  const docPipeline = [
    removeDeclarations,
    removeNonComponents,
    filterOutInheritedReactProps,
  ];
  const cleanedDocumentation = docPipeline.reduce(
    (docs, cleanUpFn) => cleanUpFn(docs),
    documentation,
  );

  const outputDir = dirname(outputPath);
  mkdirSync(outputDir, { recursive: true });

  console.log("writing documentation to:", outputPath);
  writeFileSync(outputPath, JSON.stringify(cleanedDocumentation, null, 2));
};

/**
 * react-docgen-typescript parses every export from the component file, which
 * includes functions that are not components.
 *
 * This method filters out any items that start with a lowercase letter, which is almost always
 * non-component function exports.
 *
 * @param {object} doc
 * @returns The doc without any functions
 */
const removeNonComponents = doc => {
  doc = doc.filter(item => item.displayName.match(/^[A-Z]/));

  return doc;
};

/**
 * The 'declarations' field within the generated JSON output are all the instances where the prop is referenced. Normally it's a single field, maybe two.
 * In some of our components, we're making heavy use of the XOR operator to allow and disallow certain props from being used together.
 * When react-docgen-typescript generates the JSON, it includes every variation of these references which are not useful for our documentation site.
 * In the case of Button in particular, it generated thousands of lines of JSON that were not useful (outside of the signal that our props were too complicated, which we knew already).
 *
 * We use this small recursive method (generated by GPT) to remove all instances of 'declarations' from the JSON output.
 *
 * If there's a smarter way to do this, we're all ears! This was a quick solution that is easy to remove later if we just fix our XOR usages.
 *
 * It's possible this could be used as a signal to when our props are too complicated, but that's a different conversation.
 *
 * @param {JSON} doc
 * @returns JSON without any keys called 'declarations'
 */
const removeDeclarations = doc => {
  if (Array.isArray(doc)) {
    return doc.map(removeDeclarations);
  } else if (typeof doc === "object" && doc !== null) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { declarations, ...rest } = doc;

    return Object.keys(rest).reduce((acc, key) => {
      acc[key] = removeDeclarations(rest[key]);

      return acc;
    }, {});
  }

  return doc;
};

// Explicit list of React parent types we want to exclude from docs.
const REACT_PARENT_NAMES = new Set([
  "InputHTMLAttributes",
  "HTMLAttributes",
  "AriaAttributes",
  "DOMAttributes",
  "Attributes",
]);

// Explicit keep-list: props we want to always show even if they originate
// from @types/react (e.g., `ref`).
const KEEP_PROP_NAMES = new Set(["ref"]);

/**
 * Filter out inherited React base attributes from component docs.
 * Operate only on the top-level array returned by
 * react-docgen-typescript and the top-level `props` per component.
 *
 * - Keeps prop tables focused on component-specific props
 * - Drops any prop whose parent is a React base attribute type or originates
 *   from `@types/react`
 *
 * @param {Array} docs - array of component docs from react-docgen-typescript
 * @returns {Array} new array with filtered `props` per component
 */
const filterOutInheritedReactProps = docs => {
  if (docs.length === 0) return docs;

  // Consider anything from @types/react an inherited React attribute as well.
  const isReactTypesFile = fileName =>
    typeof fileName === "string" &&
    fileName.includes("node_modules/@types/react");

  const filterPropsObject = propsObject => {
    if (!propsObject || typeof propsObject !== "object") return propsObject;

    return Object.entries(propsObject).reduce((acc, [propName, propDef]) => {
      const parentName = propDef?.parent?.name;
      const parentFile = propDef?.parent?.fileName;
      const isInheritedReactAttribute =
        REACT_PARENT_NAMES.has(parentName) || isReactTypesFile(parentFile);

      // Skip inherited React base attributes; keep only explicit component props,
      // except for props we intentionally surface (like `ref`).
      if (isInheritedReactAttribute && !KEEP_PROP_NAMES.has(propName)) {
        return acc;
      }

      acc[propName] = propDef;

      return acc;
    }, {});
  };

  return docs.map(componentDoc => {
    if (!componentDoc || typeof componentDoc !== "object") return componentDoc;

    const filteredProps = filterPropsObject(componentDoc.props);

    return { ...componentDoc, props: filteredProps };
  });
};

/**
 * Takes in 3 pieces of information (component directory, output directory, and componentname) and builds a standard path object from it.
 *
 * The pattern is currently to have a directory in the components directory that matches the component name.
 *
 * @param {string} baseComponentDir
 * @param {string} baseOutputDir
 * @param {string} componentName
 * @returns {{componentPath: string, outputPath: string}}
 */
const buildPaths = (
  baseComponentDir,
  baseOutputDir,
  componentName,
  tack = "",
) => {
  const componentPath = `${baseComponentDir}/${componentName}/${componentName}.tsx`;
  const outputPath = `${baseOutputDir}/${componentName}/${componentName}.props${tack}.json`;

  return { componentPath, outputPath };
};

/**
 * In a library world, these would be provided at run-time for more reusability but this script is hyper-specific for now.
 *
 * With these as relative paths, we also need to make sure we build from the correct location. An
 * improvement in the future would be take in the location of the script, and work from there instead (__dirname in the old world).
 */
const baseComponentDir = `../components/src`;
const baseMobileComponentDir = `../components-native/src`;
const baseOutputDir = "./src/content";

const buildComponentDocs = name => {
  const { componentPath, outputPath } = buildPaths(
    baseComponentDir,
    baseOutputDir,
    name,
  );
  parseAndWriteDocs(componentPath, outputPath);
};

const buildMobileComponentDocs = name => {
  const { componentPath, outputPath } = buildPaths(
    baseMobileComponentDir,
    baseOutputDir,
    name,
    "-mobile",
  );
  parseAndWriteDocs(componentPath, outputPath);
};

ListOfGeneratedWebComponents.forEach(buildComponentDocs);

ListOfGeneratedMobileComponents.forEach(buildMobileComponentDocs);

// V2 auto-detection: if a rebuilt file exists, emit separate V2 props
const buildWebComponentDocsV2 = name => {
  const rebuiltPath = `${baseComponentDir}/${name}/${name}.rebuilt.tsx`;
  // Write V2 props into the same directory as V1: <Component>/<Component>V2.props.json
  const v2OutputPath = `${baseOutputDir}/${name}/${name}V2.props.json`;

  if (existsSync(rebuiltPath)) {
    parseAndWriteDocs(rebuiltPath, v2OutputPath);
  }
};

ListOfGeneratedWebComponents.forEach(buildWebComponentDocsV2);
