---
name: Frontend Styleguide
menu: Guides
route: /guides/frontend-style
---

import { Playground } from "docz";

# Frontend Styleguide

## Purpose

Our goal with Typescript and React code is to automate as much style guidance as
we can. To that end this guide serves to document conventions that we can't (or
haven't yet been able to) automate. Automation is always preferred to adding a
guidance here.

## Typescript

### Linter Exceptions

While we should strive to conform to our set linter rules, if for some reason
you are unable to you should turn them off for the single line where the
exception is required.

You should also leave a comment immediately above the exception explaining why
it is necessary.

#### ‚úÖ Do

```ts
// Pending: https://github.com/donavon/use-event-listener/pull/12
// The types in useEventListener mistakenly require a SyntheticEvent for the passed generic.
// eslint-disable-next-line @typescript-eslint/ban-ts-ignore
//@ts-ignore
useEventListener<KeyboardEvent>("keydown", (event: KeyboardEvent) => {
```

```ts
// Library requires fetching its CSS.
// eslint-disable-next-line import/no-internal-modules
import "react-image-lightbox/style.css";
```

#### ‚ùå Don't

Missing rationale for disabling rule.

```ts
// eslint-disable-next-line max-statements
function MyBigComponent() {
```

```ts
const { given, expect: expectation, serverRates } = assertion;
// eslint-disable-next-line jest/valid-describe
describe(`given ${given}`, () => {
```

Missing rationale and disabling rules for a whole file.

```ts
/* eslint-disable @typescript-eslint/camelcase */
/* eslint-disable max-statements */
import React, { ReactText, useState } from "react";
```

<!--
### Choosing Libraries
-->

---

### Use XOR over Unions for conditional properties

When creating props that will change from required to optional, we prefer to use
[XOR](https://www.npmjs.com/package/ts-xor) over
[Unions](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html).
This allows us to be more secure with our `interface` by saying a type will
either be `TypeA` or `TypeB` but never a combination of both.

```tsx
import { XOR } from "ts-xor";

interface BaseComponentProps {
  readonly label?: string;
  readonly icon?: IconNames;
}

interface ComponentWithActionProps extends BaseComponentProps {
  readonly icon: IconNames;
  onClick?(): void;
}

type ComponentProps = XOR<BaseComponentProps, ComponentWithActionProps>;
```

In the example above, our `BaseComponentProps` tells us that the `label` and the
`icon` are both optional properties. In `ComponentWithActionProps` we tell
typscript that we are extending the `BaseComponentProps`, but the `icon` is now
a required property, and we have added an additional `onClick` property. The
result will look something like:

```tsx
‚úÖ
<Component label="Atlantis" icon="gift" />
‚úÖ
<Component label="Atlantis" icon="gift" onClick={() => alert('Hello üëã')} />
‚úÖ
<Component icon="gift" onClick={() => alert('Hello üëã')} />
‚ùå
<Component label="Atlantis" onClick={() => alert('Hello üëã')} />
```

The last example will cause a typescript error because we have now said that if
an `onClick` is used, then the component must be using the
`ComponentWithActionProps`. Since that is the case, the `icon` property is now
required.

---

### `function` vs arrow function

In an effort to make our Typescript code a bit more accessible we are preferring
the `function` keyword to define named functions.

#### ‚úÖ Do

```ts
function MyComponent() {
  // ...
}
```

```ts
[1, 2, 3].map(num => num * 2);
```

#### ‚ùå Don't

```ts
const MyComponent = () => {
  // ...
};
```

---

### Interface Declaration

#### ‚úÖ Do

```ts
interface MyInterface {
  foo: number;
  bar: string;
}
```

#### ‚ùå Don't

```ts
type MyInterface = {
  foo: number;
  bar: string;
};
```

<!--
## React

## Testing

### `toBeNull`

#### ‚úÖ Do

```ts

```

#### ‚ùå Don't

```ts

```

---

### `it` vs `test`

#### ‚úÖ Do

```ts

```

#### ‚ùå Don't

```ts

```

---

### Snapshots

#### ‚úÖ Do

```ts

```

#### ‚ùå Don't

```ts

```

## Mobile Specific

## Web Specific
-->

## CSS

Wherever possible use Atlantis `design` tokens.

### Units

For size units, use the appropriate [Spacing](/spacing) variables. Do not use
rems, ems, or hard-coded pixel values, as Atlantis is built using variables to
allow for consistent re-flow as the browser scales.

If you require a size that is larger than the Spacing variables, or falls
somewhere in between, use the CSS `calc` function with Atlantis spacing values
in a custom property in your file to avoid magic numbers.

#### ‚úÖ Do

```css
:root {
  --drawer-width: calc(var(--space-base) * 17.5);
}

.container {
  width: var(--drawer-width);
}
```

#### ‚ùå Don't

```css
.container {
  width: 280px;
}
```
